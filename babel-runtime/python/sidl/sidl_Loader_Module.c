/*
 * File:          sidl_Loader_Module.c
 * Symbol:        sidl.Loader-v0.9.3
 * Symbol Type:   class
 * Babel Version: 0.10.4
 * Release:       $Name$
 * Revision:      @(#) $Id$
 * Description:   implement a C extension type for a sidl extendable
 * 
 * Copyright (c) 2000-2002, The Regents of the University of California.
 * Produced at the Lawrence Livermore National Laboratory.
 * Written by the Components Team <components@llnl.gov>
 * All rights reserved.
 * 
 * This file is part of Babel. For more information, see
 * http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
 * for Our Notice and the LICENSE file for the GNU Lesser General Public
 * License.
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License (as published by
 * the Free Software Foundation) version 2.1 dated February 1999.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
 * conditions of the GNU Lesser General Public License for more details.
 * 
 * You should have recieved a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * 
 * WARNING: Automatically generated; changes will be lost
 * 
 * babel-version = 0.10.4
 */

/*
 * THIS CODE IS AUTOMATICALLY GENERATED BY THE BABEL
 * COMPILER. DO NOT EDIT THIS!
 * 
 * This file contains the implementation of a Python C
 * extension type (i.e. a Python type implemented in C).
 * This extension type provides Python interface to the
 * sidl type sidl.Loader.
 */


/**
 * Symbol "sidl.Loader" (version 0.9.3)
 * 
 * Class <code>Loader</code> manages dyanamic loading and symbol name
 * resolution for the sidl runtime system.  The <code>Loader</code> class
 * manages a library search path and keeps a record of all libraries
 * loaded through this interface, including the initial "global" symbols
 * in the main program.
 * 
 * Unless explicitly set, the <code>Loader</code> uses the default
 * <code>sidl.Finder</code> implemented in <code>sidl.DFinder</code>.
 * This class searches the filesystem for <code>.scl</code> files when
 * trying to find a class. The initial path is taken from the
 * environment variable SIDL_DLL_PATH, which is a semi-colon
 * separated sequence of URIs as described in class <code>DLL</code>.
 */
#define sidl_Loader_INTERNAL 1
#include "sidl_Loader_Module.h"
#ifndef included_sidl_Loader_IOR_h
#include "sidl_Loader_IOR.h"
#endif
#include "sidlObjA.h"
#include "sidlPyArrays.h"
#include "Numeric/arrayobject.h"
#ifndef included_sidl_Loader_h
#include "sidl_Loader.h"
#endif
#ifndef included_sidl_header_h
#include "sidl_header.h"
#endif
#ifndef included_sidl_interface_IOR_h
#include "sidl_interface_IOR.h"
#endif
#include "sidl_Finder_Module.h"
#include "sidl_DLL_Module.h"
#include "sidl_ClassInfo_Module.h"
#include "sidl_BaseInterface_Module.h"
#include "sidl_BaseClass_Module.h"
#include <stdlib.h>
#include <string.h>

staticforward PyTypeObject _sidl_LoaderType;

static struct sidl_Loader__sepv *_sepv = NULL;

static const struct sidl_Loader__external *_implEPV = NULL;

static PyObject *
pStub_Loader_setFinder(PyObject *_ignored, PyObject *_args,                   \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_Finder__object* f = NULL;
  static char *_kwlist[] = {
    "f",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "O&", _kwlist,
    (void *)sidl_Finder__convert, &f);
  if (_okay) {
    (*(_sepv->f_setFinder))(f);
    _return_value = Py_None;
    Py_INCREF(_return_value);
    sidl_Finder_deref(f);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_addSearchPath(PyObject *_ignored, PyObject *_args,               \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  char* path_fragment = NULL;
  static char *_kwlist[] = {
    "path_fragment",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "z", _kwlist,
    &path_fragment);
  if (_okay) {
    (*(_sepv->f_addSearchPath))(path_fragment);
    _return_value = Py_None;
    Py_INCREF(_return_value);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_setSearchPath(PyObject *_ignored, PyObject *_args,               \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  char* path_name = NULL;
  static char *_kwlist[] = {
    "path_name",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "z", _kwlist,
    &path_name);
  if (_okay) {
    (*(_sepv->f_setSearchPath))(path_name);
    _return_value = Py_None;
    Py_INCREF(_return_value);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_addDLL(PyObject *_ignored, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object* dll = NULL;
  static char *_kwlist[] = {
    "dll",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "O&", _kwlist,
    (void *)sidl_DLL__convert, &dll);
  if (_okay) {
    (*(_sepv->f_addDLL))(dll);
    _return_value = Py_None;
    Py_INCREF(_return_value);
    sidl_DLL_deref(dll);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_loadLibrary(PyObject *_ignored, PyObject *_args,                 \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  char* uri = NULL;
  sidl_bool loadGlobally = (sidl_bool) 0;
  sidl_bool loadLazy = (sidl_bool) 0;
  int _proxy_loadGlobally;
  int _proxy_loadLazy;
  static char *_kwlist[] = {
    "uri",
    "loadGlobally",
    "loadLazy",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "zii", _kwlist,
    &uri,
    &_proxy_loadGlobally,
    &_proxy_loadLazy);
  if (_okay) {
    struct sidl_DLL__object* _return = NULL;
    loadGlobally = (_proxy_loadGlobally ? (TRUE) : (FALSE));
    loadLazy = (_proxy_loadLazy ? (TRUE) : (FALSE));
    _return = (*(_sepv->f_loadLibrary))(uri, loadGlobally, loadLazy);
    _return_value = Py_BuildValue(
      "O&",
      (void *)sidl_DLL__wrap, _return);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_getFinder(PyObject *_ignored, PyObject *_args,                   \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  static char *_kwlist[] = {
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "", _kwlist);
  if (_okay) {
    struct sidl_Finder__object* _return = NULL;
    _return = (*(_sepv->f_getFinder))();
    _return_value = Py_BuildValue(
      "O&",
      (void *)sidl_Finder__wrap, _return);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_getSearchPath(PyObject *_ignored, PyObject *_args,               \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  static char *_kwlist[] = {
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "", _kwlist);
  if (_okay) {
    char* _return = NULL;
    _return = (*(_sepv->f_getSearchPath))();
    _return_value = Py_BuildValue(
      "z",
      _return);
    free((void *)_return);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_unloadLibraries(PyObject *_ignored, PyObject *_args,             \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  static char *_kwlist[] = {
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "", _kwlist);
  if (_okay) {
    (*(_sepv->f_unloadLibraries))();
    _return_value = Py_None;
    Py_INCREF(_return_value);
  }
  return _return_value;
}

static PyObject *
pStub_Loader_findLibrary(PyObject *_ignored, PyObject *_args,                 \
  PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  char* sidl_name = NULL;
  char* target = NULL;
  enum sidl_Scope__enum lScope = (enum sidl_Scope__enum) 0;
  enum sidl_Resolve__enum lResolve = (enum sidl_Resolve__enum) 0;
  long _proxy_lScope;
  long _proxy_lResolve;
  static char *_kwlist[] = {
    "sidl_name",
    "target",
    "lScope",
    "lResolve",
    NULL
  };
  const int _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "zzll", _kwlist,
    &sidl_name,
    &target,
    &_proxy_lScope,
    &_proxy_lResolve);
  if (_okay) {
    struct sidl_DLL__object* _return = NULL;
    lScope = _proxy_lScope;
    lResolve = _proxy_lResolve;
    _return = (*(_sepv->f_findLibrary))(sidl_name, target, lScope, lResolve);
    _return_value = Py_BuildValue(
      "O&",
      (void *)sidl_DLL__wrap, _return);
  }
  return _return_value;
}

static int
sidl_Loader_createCast(PyObject *self, PyObject *args, PyObject *kwds) {
  struct sidl_Loader__object *optarg = NULL;
  static char *_kwlist[] = { "sobj", NULL };
  int _okay = PyArg_ParseTupleAndKeywords(args, kwds, "|O&", _kwlist,         \
    (void *)sidl_Loader__convert, &optarg);
  if (_okay) {
    if (!optarg) {
      optarg = (*(_implEPV->createObject))();
    }
    return sidl_Object_Init(
      (SPObject *)self,
      (struct sidl_BaseInterface__object *)optarg,
      sidl_PyStealRef);
  }
  return -1;
}

static PyMethodDef _LoaderModuleMethods[] = {
  { "addDLL", (PyCFunction)pStub_Loader_addDLL,
  (METH_VARARGS | METH_KEYWORDS),
"\
addDLL(in sidl.DLL dll)\n\
RETURNS\n\
    None\n\
\n\
\
Append the specified DLL to the beginning of the list of already\n\
loaded DLLs."
   },
  { "addSearchPath", (PyCFunction)pStub_Loader_addSearchPath,
  (METH_VARARGS | METH_KEYWORDS),
"\
addSearchPath(in string path_fragment)\n\
RETURNS\n\
    None\n\
\n\
\
Append the specified path fragment to the beginning of the\n\
current search path.  This method operates on the Loader's\n\
current <code>Finder</code>. This will add a path to the\n\
current search path. Normally, the search path is initialized\n\
from the SIDL_DLL_PATH environment variable."
   },
  { "findLibrary", (PyCFunction)pStub_Loader_findLibrary,
  (METH_VARARGS | METH_KEYWORDS),
"\
findLibrary(in string sidl_name,\n\
            in string target,\n\
            in sidl.Scope lScope,\n\
            in sidl.Resolve lResolve)\n\
RETURNS\n\
   (sidl.DLL _return)\n\
\n\
\
Find a DLL containing the specified information for a sidl\n\
class. This method searches SCL files in the search path looking\n\
for a shared library that contains the client-side or IOR\n\
for a particular sidl class.\n\
\n\
This call is implemented by calling the current\n\
<code>Finder</code>. The default finder searches the local\n\
file system for <code>.scl</code> files to locate the\n\
target class/interface.\n\
\n\
@param sidl_name  the fully qualified (long) name of the\n\
                  class/interface to be found. Package names\n\
                  are separated by period characters from each\n\
                  other and the class/interface name.\n\
@param target     to find a client-side binding, this is\n\
                  normally the name of the language.\n\
                  To find the implementation of a class\n\
                  in order to make one, you should pass\n\
                  the string \"ior/impl\" here.\n\
@param lScope     this specifies whether the symbols should\n\
                  be loaded into the global scope, a local\n\
                  scope, or use the setting in the SCL file.\n\
@param lResolve   this specifies whether symbols should be\n\
                  resolved as needed (LAZY), completely\n\
                  resolved at load time (NOW), or use the\n\
                  setting from the SCL file.\n\
@return a non-NULL object means the search was successful.\n\
        The DLL has already been added."
   },
  { "getFinder", (PyCFunction)pStub_Loader_getFinder,
  (METH_VARARGS | METH_KEYWORDS),
"\
getFinder()\n\
RETURNS\n\
   (sidl.Finder _return)\n\
\n\
\
This method gets the <code>Finder</code> that <code>Loader</code>\n\
uses to find DLLs.  "
   },
  { "getSearchPath", (PyCFunction)pStub_Loader_getSearchPath,
  (METH_VARARGS | METH_KEYWORDS),
"\
getSearchPath()\n\
RETURNS\n\
   (string _return)\n\
\n\
\
Return the current search path.  The default\n\
<code>Finder</code> initializes the search path\n\
from environment variable SIDL_DLL_PATH.\n\
"
   },
  { "loadLibrary", (PyCFunction)pStub_Loader_loadLibrary,
  (METH_VARARGS | METH_KEYWORDS),
"\
loadLibrary(in string uri,\n\
            in bool loadGlobally,\n\
            in bool loadLazy)\n\
RETURNS\n\
   (sidl.DLL _return)\n\
\n\
\
Load the specified library if it has not already been loaded.\n\
The URI format is defined in class <code>DLL</code>.  The search\n\
path is not searched to resolve the library name.\n\
\n\
@param uri          the URI to load. This can be a .la file\n\
                    (a metadata file produced by libtool) or\n\
                    a shared library binary (i.e., .so,\n\
                    .dll or whatever is appropriate for your\n\
                    OS)\n\
@param loadGlobally <code>true</code> means that the shared\n\
                    library symbols will be loaded into the\n\
                    global namespace; <code>false</code> \n\
                    means they will be loaded into a \n\
                    private namespace. Some operating systems\n\
                    may not be able to honor the value presented\n\
                    here.\n\
@param loadLazy     <code>true</code> instructs the loader to\n\
                    that symbols can be resolved as needed (lazy)\n\
                    instead of requiring everything to be resolved\n\
                    now.\n\
@return if the load was successful, a non-NULL DLL object is returned."
   },
  { "setFinder", (PyCFunction)pStub_Loader_setFinder,
  (METH_VARARGS | METH_KEYWORDS),
"\
setFinder(in sidl.Finder f)\n\
RETURNS\n\
    None\n\
\n\
\
This method sets the <code>Finder</code> that\n\
<code>Loader</code> will use to find DLLs.  If no\n\
<code>Finder</code> is set or if NULL is passed in, the Default\n\
Finder <code>DFinder</code> will be used.\n\
\n\
Future calls to <code>findLibrary</code>,\n\
<code>addSearchPath</code>, <code>getSearchPath</code>, and\n\
<code>setSearchPath</code> are deligated to the\n\
<code>Finder</code> set here."
   },
  { "setSearchPath", (PyCFunction)pStub_Loader_setSearchPath,
  (METH_VARARGS | METH_KEYWORDS),
"\
setSearchPath(in string path_name)\n\
RETURNS\n\
    None\n\
\n\
\
Set the search path, which is a semi-colon separated sequence of\n\
URIs as described in class <code>DLL</code>.  This method will\n\
invalidate any existing search path.\n\
\n\
This updates the search path in the current <code>Finder</code>."
   },
  { "unloadLibraries", (PyCFunction)pStub_Loader_unloadLibraries,
  (METH_VARARGS | METH_KEYWORDS),
"\
unloadLibraries()\n\
RETURNS\n\
    None\n\
\n\
\
Unload all dynamic link libraries.  The library may no longer\n\
be used to access symbol names.  When the library is actually\n\
unloaded from the memory image depends on details of the operating\n\
system."
   },
  { NULL, NULL }
};

static PyMethodDef _LoaderObjectMethods[] = {
  { NULL, NULL }
};

static PyTypeObject _sidl_LoaderType = {
  PyObject_HEAD_INIT(NULL)
  0,      /* ob_size */
  "sidl.Loader.Loader", /* tp_name */
  0,      /* tp_basicsize */
  0,      /* tp_itemsize */
  0,      /* tp_dealloc */
  0,      /* tp_print */
  0,      /* tp_getattr */
  0,      /* tp_setattr */
  0,      /* tp_compare */
  0,      /* tp_repr */
  0,      /* tp_as_number */
  0,      /* tp_as_sequence */
  0,      /* tp_as_mapping */
  0,      /* tp_hash  */
  0,      /* tp_call */
  0,      /* tp_str */
  0,      /* tp_getattro */
  0,      /* tp_setattro */
  0,      /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT, /* tp_flags */
  "\
\
Class <code>Loader</code> manages dyanamic loading and symbol name\n\
resolution for the sidl runtime system.  The <code>Loader</code> class\n\
manages a library search path and keeps a record of all libraries\n\
loaded through this interface, including the initial \"global\" symbols\n\
in the main program.\n\
\n\
Unless explicitly set, the <code>Loader</code> uses the default\n\
<code>sidl.Finder</code> implemented in <code>sidl.DFinder</code>.\n\
This class searches the filesystem for <code>.scl</code> files when\n\
trying to find a class. The initial path is taken from the\n\
environment variable SIDL_DLL_PATH, which is a semi-colon\n\
separated sequence of URIs as described in class <code>DLL</code>.", /* tp_doc */
  0,      /* tp_traverse */
  0,       /* tp_clear */
  0,       /* tp_richcompare */
  0,       /* tp_weaklistoffset */
  0,       /* tp_iter */
  0,       /* tp_iternext */
  _LoaderObjectMethods, /* tp_methods */
  0,       /* tp_members */
  0,       /* tp_getset */
  0,       /* tp_base */
  0,       /* tp_dict */
  0,       /* tp_descr_get */
  0,       /* tp_descr_set */
  0,       /* tp_dictoffset */
  sidl_Loader_createCast,   /* tp_init */
  0,       /* tp_alloc */
  0,       /* tp_new */
};

sidl_Loader__wrap_RETURN
sidl_Loader__wrap sidl_Loader__wrap_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_LoaderType.tp_new(&_sidl_LoaderType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyStealRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_Loader__weakRef_RETURN
sidl_Loader__weakRef sidl_Loader__weakRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_LoaderType.tp_new(&_sidl_LoaderType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyWeakRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_Loader_deref_RETURN
sidl_Loader_deref sidl_Loader_deref_PROTO {
  if (sidlobj) {
    (*(sidlobj->d_epv->f_deleteRef))(sidlobj);
  }
}

sidl_Loader__newRef_RETURN
sidl_Loader__newRef sidl_Loader__newRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_LoaderType.tp_new(&_sidl_LoaderType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyNewRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_Loader__addRef_RETURN
sidl_Loader__addRef sidl_Loader__addRef_PROTO {
  if (sidlobj) {
    (*(sidlobj->d_epv->f_addRef))(sidlobj);
  }
}

sidl_Loader_PyType_RETURN
sidl_Loader_PyType sidl_Loader_PyType_PROTO {
  Py_INCREF(&_sidl_LoaderType);
  return &_sidl_LoaderType;
}

sidl_Loader__convert_RETURN
sidl_Loader__convert sidl_Loader__convert_PROTO {
  *sidlobj = sidl_Cast(obj, "sidl.Loader");
  if (*sidlobj) {
    (*((*sidlobj)->d_epv->f_addRef))(*sidlobj);
  }
  else if (obj != Py_None) {
    PyErr_SetString(PyExc_TypeError, 
      "argument is not a(n) sidl.Loader");
    return 0;
  }
  return 1;
}

static int
_convertPython(void *sidlarray, const int *ind, PyObject *pyobj)
{
  struct sidl_Loader__object *sidlobj;
  if (sidl_Loader__convert(pyobj, &sidlobj)) {
    sidl_interface__array_set((struct sidl_interface__array *)sidlarray,
    ind, (struct sidl_BaseInterface__object *)sidlobj);
    if (sidlobj) {
      sidl_BaseInterface_deleteRef((struct sidl_BaseInterface__object         \
        *)sidlobj);
    }
    return FALSE;
  }
  return TRUE;
}

sidl_Loader__convert_python_array_RETURN
sidl_Loader__convert_python_array sidl_Loader__convert_python_array_PROTO {
  int result = 0;
  *sidlarray = NULL;
  if (obj == Py_None) {
    result = TRUE;
  }
  else {
    PyObject *pya = PyArray_FromObject(obj, PyArray_OBJECT, 0, 0);
    if (pya) {
      if (PyArray_OBJECT == ((PyArrayObject *)pya)->descr->type_num) {
        int dimen, lower[SIDL_MAX_ARRAY_DIMENSION],
          upper[SIDL_MAX_ARRAY_DIMENSION],
          stride[SIDL_MAX_ARRAY_DIMENSION];
        if (sidl_array__extract_python_info
          (pya, &dimen, lower, upper, stride))
        {
            *sidlarray = (struct                                              \
              sidl_Loader__array*)sidl_interface__array_createRow
            (dimen, lower, upper);
          result = sidl_array__convert_python
            (pya, dimen, *sidlarray, _convertPython);
          if (*sidlarray && !result) {
            sidl_interface__array_deleteRef(
              (struct  sidl_interface__array *)*sidlarray);
            *sidlarray = NULL;
          }
        }
      }
      Py_DECREF(pya);
    }
  }
  return result;
}

static int
_convertSIDL(void *sidlarray, const int *ind, PyObject **dest)
{
  struct sidl_Loader__object *sidlobj = (struct sidl_Loader__object*)
  sidl_interface__array_get((struct sidl_interface__array *)
    sidlarray, ind);
  *dest = sidl_Loader__wrap(sidlobj);
  return (*dest == NULL);
}

sidl_Loader__convert_sidl_array_RETURN
sidl_Loader__convert_sidl_array sidl_Loader__convert_sidl_array_PROTO {
  PyObject *pya = NULL;
  if (sidlarray) {
    const int dimen = sidlArrayDim(sidlarray);
    int i;
    int *lower = (int *)malloc(sizeof(int) * dimen);
    int *upper = (int *)malloc(sizeof(int) * dimen);
    int *numelem = (int *)malloc(sizeof(int) * dimen);
    for(i = 0; i < dimen; ++i) {
      lower[i] = sidlLower(sidlarray, i);
      upper[i] = sidlUpper(sidlarray, i);
      numelem[i] = 1 + upper[i] - lower[i];
    }
    pya = PyArray_FromDims(dimen, numelem, PyArray_OBJECT);
    if (pya) {
      if (!sidl_array__convert_sidl(pya, dimen, lower, upper,
        numelem, sidlarray, _convertSIDL))
      {
        Py_DECREF(pya);
        pya = NULL;
      }
    }
    free(numelem);
    free(upper);
    free(lower);
  }
  else {
    Py_INCREF(Py_None);
    pya = Py_None;
  }
  return pya;
}

void
initLoader(void) {
  PyObject *module, *dict, *c_api;
  static void *ExternalAPI[sidl_Loader__API_NUM];
  module = Py_InitModule3("Loader", _LoaderModuleMethods, "\
\
Class <code>Loader</code> manages dyanamic loading and symbol name\n\
resolution for the sidl runtime system.  The <code>Loader</code> class\n\
manages a library search path and keeps a record of all libraries\n\
loaded through this interface, including the initial \"global\" symbols\n\
in the main program.\n\
\n\
Unless explicitly set, the <code>Loader</code> uses the default\n\
<code>sidl.Finder</code> implemented in <code>sidl.DFinder</code>.\n\
This class searches the filesystem for <code>.scl</code> files when\n\
trying to find a class. The initial path is taken from the\n\
environment variable SIDL_DLL_PATH, which is a semi-colon\n\
separated sequence of URIs as described in class <code>DLL</code>."
  );
  dict = PyModule_GetDict(module);
  ExternalAPI[sidl_Loader__wrap_NUM] = (void*)sidl_Loader__wrap;
  ExternalAPI[sidl_Loader__convert_NUM] = (void*)sidl_Loader__convert;
  ExternalAPI[sidl_Loader__convert_python_array_NUM] =                        \
    (void*)sidl_Loader__convert_python_array;
  ExternalAPI[sidl_Loader__convert_sidl_array_NUM] =                          \
    (void*)sidl_Loader__convert_sidl_array;
  ExternalAPI[sidl_Loader__weakRef_NUM] = (void*)sidl_Loader__weakRef;
  ExternalAPI[sidl_Loader_deref_NUM] = (void*)sidl_Loader_deref;
  ExternalAPI[sidl_Loader__newRef_NUM] = (void*)sidl_Loader__newRef;
  ExternalAPI[sidl_Loader__addRef_NUM] = (void*)sidl_Loader__addRef;
  ExternalAPI[sidl_Loader_PyType_NUM] = (void*)sidl_Loader_PyType;
  import_SIDLObjA();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlObjA module.");
  }
  c_api = PyCObject_FromVoidPtr((void *)ExternalAPI, NULL);
  PyDict_SetItemString(dict, "_C_API", c_api);
  Py_XDECREF(c_api);
  import_SIDLPyArrays();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlPyArrays module.");
  }
  import_array();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing Numeric Python module.");
  }
  sidl_BaseClass__import();
  _sidl_LoaderType.tp_base = sidl_BaseClass_PyType();
  _sidl_LoaderType.tp_bases = PyTuple_New(1);
  PyTuple_SetItem(_sidl_LoaderType.tp_bases,0,                                \
    (PyObject *)sidl_BaseClass_PyType());
  if (PyType_Ready(&_sidl_LoaderType) < 0) {
    PyErr_Print();
    fprintf(stderr, "PyType_Ready on sidl.Loader failed.\n");
    return;
  }
  Py_INCREF(&_sidl_LoaderType);
  PyDict_SetItemString(dict, "Loader", (PyObject *)&_sidl_LoaderType);
  sidl_ClassInfo__import();
  sidl_BaseInterface__import();
  sidl_Finder__import();
  sidl_DLL__import();
  _implEPV = sidl_Loader__externals();
  if (_implEPV) {
    _sepv = (*_implEPV->getStaticEPV)();
    if (PyErr_Occurred()) {
      Py_FatalError("Cannot initialize Python module sidl.Loader.");
    }
  }
  else {
    Py_FatalError("Cannot load implementation for sidl class sidl.Loader");
  }
}

/*
 * File:          sidl_DLL_Module.c
 * Symbol:        sidl.DLL-v0.9.3
 * Symbol Type:   class
 * Babel Version: 0.10.12
 * Release:       $Name$
 * Revision:      @(#) $Id$
 * Description:   implement a C extension type for a sidl extendable
 * 
 * Copyright (c) 2000-2002, The Regents of the University of California.
 * Produced at the Lawrence Livermore National Laboratory.
 * Written by the Components Team <components@llnl.gov>
 * All rights reserved.
 * 
 * This file is part of Babel. For more information, see
 * http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
 * for Our Notice and the LICENSE file for the GNU Lesser General Public
 * License.
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License (as published by
 * the Free Software Foundation) version 2.1 dated February 1999.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
 * conditions of the GNU Lesser General Public License for more details.
 * 
 * You should have recieved a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * 
 * WARNING: Automatically generated; changes will be lost
 * 
 * babel-version = 0.10.12
 */

/*
 * THIS CODE IS AUTOMATICALLY GENERATED BY THE BABEL
 * COMPILER. DO NOT EDIT THIS!
 * 
 * This file contains the implementation of a Python C
 * extension type (i.e. a Python type implemented in C).
 * This extension type provides Python interface to the
 * sidl type sidl.DLL.
 */


/**
 * Symbol "sidl.DLL" (version 0.9.3)
 * 
 * The <code>DLL</code> class encapsulates access to a single
 * dynamically linked library.  DLLs are loaded at run-time using
 * the <code>loadLibrary</code> method and later unloaded using
 * <code>unloadLibrary</code>.  Symbols in a loaded library are
 * resolved to an opaque pointer by method <code>lookupSymbol</code>.
 * Class instances are created by <code>createClass</code>.
 */
#define sidl_DLL_INTERNAL 1
#include "sidl_DLL_Module.h"
#ifndef included_sidl_DLL_IOR_h
#include "sidl_DLL_IOR.h"
#endif
#include "sidlObjA.h"
#include "sidlPyArrays.h"
#include "Numeric/arrayobject.h"
#ifndef included_sidl_Loader_h
#include "sidl_Loader.h"
#endif
#ifndef included_sidl_header_h
#include "sidl_header.h"
#endif
#ifndef included_sidl_interface_IOR_h
#include "sidl_interface_IOR.h"
#endif
#include "sidl_BaseClass_Module.h"
#include "sidl_BaseInterface_Module.h"
#include "sidl_ClassInfo_Module.h"
#include <stdlib.h>
#include <string.h>

staticforward PyTypeObject _sidl_DLLType;

static const struct sidl_DLL__external *_implEPV = NULL;

static PyObject *
pStub_DLL_createClass(PyObject *_self, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object *_self_ior =
    ((struct sidl_DLL__object *)
     sidl_Cast(_self, "sidl.DLL"));
  if (_self_ior) {
    char* sidl_name = NULL;
    static char *_kwlist[] = {
      "sidl_name",
      NULL
    };
    const int _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "z", _kwlist,
      &sidl_name);
    if (_okay) {
      struct sidl_BaseClass__object* _return = NULL;
      _return = (*(_self_ior->d_epv->f_createClass))(_self_ior, sidl_name);
      _return_value = Py_BuildValue(
        "O&",
        (void *)sidl_BaseClass__wrap, _return);
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidl.DLL");
  }
  return _return_value;
}

static PyObject *
pStub_DLL_loadLibrary(PyObject *_self, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object *_self_ior =
    ((struct sidl_DLL__object *)
     sidl_Cast(_self, "sidl.DLL"));
  if (_self_ior) {
    char* uri = NULL;
    sidl_bool loadGlobally = (sidl_bool) 0;
    sidl_bool loadLazy = (sidl_bool) 0;
    int _proxy_loadGlobally;
    int _proxy_loadLazy;
    static char *_kwlist[] = {
      "uri",
      "loadGlobally",
      "loadLazy",
      NULL
    };
    const int _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "zii", _kwlist,
      &uri,
      &_proxy_loadGlobally,
      &_proxy_loadLazy);
    if (_okay) {
      sidl_bool _return = (sidl_bool) 0;
      int _proxy__return;
      loadGlobally = (_proxy_loadGlobally ? (TRUE) : (FALSE));
      loadLazy = (_proxy_loadLazy ? (TRUE) : (FALSE));
      _return = (*(_self_ior->d_epv->f_loadLibrary))(_self_ior, uri,          \
        loadGlobally, loadLazy);
      _proxy__return = _return;
      _return_value = Py_BuildValue(
        "i",
        _proxy__return);
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidl.DLL");
  }
  return _return_value;
}

static PyObject *
pStub_DLL_getName(PyObject *_self, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object *_self_ior =
    ((struct sidl_DLL__object *)
     sidl_Cast(_self, "sidl.DLL"));
  if (_self_ior) {
    static char *_kwlist[] = {
      NULL
    };
    const int _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      char* _return = NULL;
      _return = (*(_self_ior->d_epv->f_getName))(_self_ior);
      _return_value = Py_BuildValue(
        "z",
        _return);
      free((void *)_return);
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidl.DLL");
  }
  return _return_value;
}

static PyObject *
pStub_DLL_lookupSymbol(PyObject *_self, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object *_self_ior =
    ((struct sidl_DLL__object *)
     sidl_Cast(_self, "sidl.DLL"));
  if (_self_ior) {
    char* linker_name = NULL;
    static char *_kwlist[] = {
      "linker_name",
      NULL
    };
    const int _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "z", _kwlist,
      &linker_name);
    if (_okay) {
      void* _return = NULL;
      _return = (*(_self_ior->d_epv->f_lookupSymbol))(_self_ior, linker_name);
      _return_value = Py_BuildValue(
        "O&",
        (void *)sidl_Opaque_Create, _return);
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidl.DLL");
  }
  return _return_value;
}

static PyObject *
pStub_DLL_unloadLibrary(PyObject *_self, PyObject *_args, PyObject *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidl_DLL__object *_self_ior =
    ((struct sidl_DLL__object *)
     sidl_Cast(_self, "sidl.DLL"));
  if (_self_ior) {
    static char *_kwlist[] = {
      NULL
    };
    const int _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      (*(_self_ior->d_epv->f_unloadLibrary))(_self_ior);
      _return_value = Py_None;
      Py_INCREF(_return_value);
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidl.DLL");
  }
  return _return_value;
}

static int
sidl_DLL_createCast(PyObject *self, PyObject *args, PyObject *kwds) {
  struct sidl_DLL__object *optarg = NULL;
  static char *_kwlist[] = { "sobj", NULL };
  int _okay = PyArg_ParseTupleAndKeywords(args, kwds, "|O&", _kwlist,         \
    (void *)sidl_DLL__convert, &optarg);
  if (_okay) {
    if (!optarg) {
      optarg = (*(_implEPV->createObject))();
    }
    return sidl_Object_Init(
      (SPObject *)self,
      (struct sidl_BaseInterface__object *)optarg,
      sidl_PyStealRef);
  }
  return -1;
}

static PyMethodDef _DLLModuleMethods[] = {
  { NULL, NULL }
};

static PyMethodDef _DLLObjectMethods[] = {
  { "createClass", (PyCFunction)pStub_DLL_createClass,
  (METH_VARARGS | METH_KEYWORDS),
"\
createClass(in string sidl_name)\n\
RETURNS\n\
   (sidl.BaseClass _return)\n\
\n\
\
Create an instance of the sidl class.  If the class constructor\n\
is not defined in this DLL, then return null."
   },
  { "getName", (PyCFunction)pStub_DLL_getName,
  (METH_VARARGS | METH_KEYWORDS),
"\
getName()\n\
RETURNS\n\
   (string _return)\n\
\n\
\
Get the library name.  This is the name used to load the\n\
library in <code>loadLibrary</code> except that all file names\n\
contain the \"file:\" protocol."
   },
  { "loadLibrary", (PyCFunction)pStub_DLL_loadLibrary,
  (METH_VARARGS | METH_KEYWORDS),
"\
loadLibrary(in string uri,\n\
            in bool loadGlobally,\n\
            in bool loadLazy)\n\
RETURNS\n\
   (bool _return)\n\
\n\
\
Load a dynamic link library using the specified URI.  The\n\
URI may be of the form \"main:\", \"lib:\", \"file:\", \"ftp:\", or\n\
\"http:\".  A URI that starts with any other protocol string\n\
is assumed to be a file name.  The \"main:\" URI creates a\n\
library that allows access to global symbols in the running\n\
program's main address space.  The \"lib:X\" URI converts the\n\
library \"X\" into a platform-specific name (e.g., libX.so) and\n\
loads that library.  The \"file:\" URI opens the DLL from the\n\
specified file path.  The \"ftp:\" and \"http:\" URIs copy the\n\
specified library from the remote site into a local temporary\n\
file and open that file.  This method returns true if the\n\
DLL was loaded successfully and false otherwise.  Note that\n\
the \"ftp:\" and \"http:\" protocols are valid only if the W3C\n\
WWW library is available.\n\
\n\
@param uri          the URI to load. This can be a .la file\n\
                    (a metadata file produced by libtool) or\n\
                    a shared library binary (i.e., .so,\n\
                    .dll or whatever is appropriate for your\n\
                    OS)\n\
@param loadGlobally <code>true</code> means that the shared\n\
                    library symbols will be loaded into the\n\
                    global namespace; <code>false</code> \n\
                    means they will be loaded into a \n\
                    private namespace. Some operating systems\n\
                    may not be able to honor the value presented\n\
                    here.\n\
@param loadLazy     <code>true</code> instructs the loader to\n\
                    that symbols can be resolved as needed (lazy)\n\
                    instead of requiring everything to be resolved\n\
                    now (at load time)."
   },
  { "lookupSymbol", (PyCFunction)pStub_DLL_lookupSymbol,
  (METH_VARARGS | METH_KEYWORDS),
"\
lookupSymbol(in string linker_name)\n\
RETURNS\n\
   (opaque _return)\n\
\n\
\
Lookup a symbol from the DLL and return the associated pointer.\n\
A null value is returned if the name does not exist."
   },
  { "unloadLibrary", (PyCFunction)pStub_DLL_unloadLibrary,
  (METH_VARARGS | METH_KEYWORDS),
"\
unloadLibrary()\n\
RETURNS\n\
    None\n\
\n\
\
Unload the dynamic link library.  The library may no longer\n\
be used to access symbol names.  When the library is actually\n\
unloaded from the memory image depends on details of the operating\n\
system."
   },
  { NULL, NULL }
};

static PyTypeObject _sidl_DLLType = {
  PyObject_HEAD_INIT(NULL)
  0,      /* ob_size */
  "sidl.DLL.DLL", /* tp_name */
  0,      /* tp_basicsize */
  0,      /* tp_itemsize */
  0,      /* tp_dealloc */
  0,      /* tp_print */
  0,      /* tp_getattr */
  0,      /* tp_setattr */
  0,      /* tp_compare */
  0,      /* tp_repr */
  0,      /* tp_as_number */
  0,      /* tp_as_sequence */
  0,      /* tp_as_mapping */
  0,      /* tp_hash  */
  0,      /* tp_call */
  0,      /* tp_str */
  0,      /* tp_getattro */
  0,      /* tp_setattro */
  0,      /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT, /* tp_flags */
  "\
\
The <code>DLL</code> class encapsulates access to a single\n\
dynamically linked library.  DLLs are loaded at run-time using\n\
the <code>loadLibrary</code> method and later unloaded using\n\
<code>unloadLibrary</code>.  Symbols in a loaded library are\n\
resolved to an opaque pointer by method <code>lookupSymbol</code>.\n\
Class instances are created by <code>createClass</code>.", /* tp_doc */
  0,      /* tp_traverse */
  0,       /* tp_clear */
  0,       /* tp_richcompare */
  0,       /* tp_weaklistoffset */
  0,       /* tp_iter */
  0,       /* tp_iternext */
  _DLLObjectMethods, /* tp_methods */
  0,       /* tp_members */
  0,       /* tp_getset */
  0,       /* tp_base */
  0,       /* tp_dict */
  0,       /* tp_descr_get */
  0,       /* tp_descr_set */
  0,       /* tp_dictoffset */
  sidl_DLL_createCast,   /* tp_init */
  0,       /* tp_alloc */
  0,       /* tp_new */
};

sidl_DLL__wrap_RETURN
sidl_DLL__wrap sidl_DLL__wrap_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_DLLType.tp_new(&_sidl_DLLType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyStealRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_DLL__weakRef_RETURN
sidl_DLL__weakRef sidl_DLL__weakRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_DLLType.tp_new(&_sidl_DLLType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyWeakRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_DLL_deref_RETURN
sidl_DLL_deref sidl_DLL_deref_PROTO {
  if (sidlobj) {
    (*(sidlobj->d_epv->f_deleteRef))(sidlobj);
  }
}

sidl_DLL__newRef_RETURN
sidl_DLL__newRef sidl_DLL__newRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidl_DLLType.tp_new(&_sidl_DLLType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyNewRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidl_DLL__addRef_RETURN
sidl_DLL__addRef sidl_DLL__addRef_PROTO {
  if (sidlobj) {
    (*(sidlobj->d_epv->f_addRef))(sidlobj);
  }
}

sidl_DLL_PyType_RETURN
sidl_DLL_PyType sidl_DLL_PyType_PROTO {
  Py_INCREF(&_sidl_DLLType);
  return &_sidl_DLLType;
}

sidl_DLL__convert_RETURN
sidl_DLL__convert sidl_DLL__convert_PROTO {
  *sidlobj = sidl_Cast(obj, "sidl.DLL");
  if (*sidlobj) {
    (*((*sidlobj)->d_epv->f_addRef))(*sidlobj);
  }
  else if (obj != Py_None) {
    PyErr_SetString(PyExc_TypeError, 
      "argument is not a(n) sidl.DLL");
    return 0;
  }
  return 1;
}

static int
_convertPython(void *sidlarray, const int *ind, PyObject *pyobj)
{
  struct sidl_DLL__object *sidlobj;
  if (sidl_DLL__convert(pyobj, &sidlobj)) {
    sidl_interface__array_set((struct sidl_interface__array *)sidlarray,
    ind, (struct sidl_BaseInterface__object *)sidlobj);
    if (sidlobj) {
      sidl_BaseInterface_deleteRef((struct sidl_BaseInterface__object         \
        *)sidlobj);
    }
    return FALSE;
  }
  return TRUE;
}

sidl_DLL__convert_python_array_RETURN
sidl_DLL__convert_python_array sidl_DLL__convert_python_array_PROTO {
  int result = 0;
  *sidlarray = NULL;
  if (obj == Py_None) {
    result = TRUE;
  }
  else {
    PyObject *pya = PyArray_FromObject(obj, PyArray_OBJECT, 0, 0);
    if (pya) {
      if (PyArray_OBJECT == ((PyArrayObject *)pya)->descr->type_num) {
        int dimen, lower[SIDL_MAX_ARRAY_DIMENSION],
          upper[SIDL_MAX_ARRAY_DIMENSION],
          stride[SIDL_MAX_ARRAY_DIMENSION];
        if (sidl_array__extract_python_info
          (pya, &dimen, lower, upper, stride))
        {
            *sidlarray = (struct                                              \
              sidl_DLL__array*)sidl_interface__array_createRow
            (dimen, lower, upper);
          result = sidl_array__convert_python
            (pya, dimen, *sidlarray, _convertPython);
          if (*sidlarray && !result) {
            sidl_interface__array_deleteRef(
              (struct  sidl_interface__array *)*sidlarray);
            *sidlarray = NULL;
          }
        }
      }
      Py_DECREF(pya);
    }
  }
  return result;
}

static int
_convertSIDL(void *sidlarray, const int *ind, PyObject **dest)
{
  struct sidl_DLL__object *sidlobj = (struct sidl_DLL__object*)
  sidl_interface__array_get((struct sidl_interface__array *)
    sidlarray, ind);
  *dest = sidl_DLL__wrap(sidlobj);
  return (*dest == NULL);
}

sidl_DLL__convert_sidl_array_RETURN
sidl_DLL__convert_sidl_array sidl_DLL__convert_sidl_array_PROTO {
  PyObject *pya = NULL;
  if (sidlarray) {
    const int dimen = sidlArrayDim(sidlarray);
    int i;
    int *lower = (int *)malloc(sizeof(int) * dimen);
    int *upper = (int *)malloc(sizeof(int) * dimen);
    int *numelem = (int *)malloc(sizeof(int) * dimen);
    for(i = 0; i < dimen; ++i) {
      lower[i] = sidlLower(sidlarray, i);
      upper[i] = sidlUpper(sidlarray, i);
      numelem[i] = 1 + upper[i] - lower[i];
    }
    pya = PyArray_FromDims(dimen, numelem, PyArray_OBJECT);
    if (pya) {
      if (!sidl_array__convert_sidl(pya, dimen, lower, upper,
        numelem, sidlarray, _convertSIDL))
      {
        Py_DECREF(pya);
        pya = NULL;
      }
    }
    free(numelem);
    free(upper);
    free(lower);
  }
  else {
    Py_INCREF(Py_None);
    pya = Py_None;
  }
  return pya;
}

void
initDLL(void) {
  PyObject *module, *dict, *c_api;
  static void *ExternalAPI[sidl_DLL__API_NUM];
  module = Py_InitModule3("DLL", _DLLModuleMethods, "\
\
The <code>DLL</code> class encapsulates access to a single\n\
dynamically linked library.  DLLs are loaded at run-time using\n\
the <code>loadLibrary</code> method and later unloaded using\n\
<code>unloadLibrary</code>.  Symbols in a loaded library are\n\
resolved to an opaque pointer by method <code>lookupSymbol</code>.\n\
Class instances are created by <code>createClass</code>."
  );
  dict = PyModule_GetDict(module);
  ExternalAPI[sidl_DLL__wrap_NUM] = (void*)sidl_DLL__wrap;
  ExternalAPI[sidl_DLL__convert_NUM] = (void*)sidl_DLL__convert;
  ExternalAPI[sidl_DLL__convert_python_array_NUM] =                           \
    (void*)sidl_DLL__convert_python_array;
  ExternalAPI[sidl_DLL__convert_sidl_array_NUM] =                             \
    (void*)sidl_DLL__convert_sidl_array;
  ExternalAPI[sidl_DLL__weakRef_NUM] = (void*)sidl_DLL__weakRef;
  ExternalAPI[sidl_DLL_deref_NUM] = (void*)sidl_DLL_deref;
  ExternalAPI[sidl_DLL__newRef_NUM] = (void*)sidl_DLL__newRef;
  ExternalAPI[sidl_DLL__addRef_NUM] = (void*)sidl_DLL__addRef;
  ExternalAPI[sidl_DLL_PyType_NUM] = (void*)sidl_DLL_PyType;
  import_SIDLObjA();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlObjA module.");
  }
  c_api = PyCObject_FromVoidPtr((void *)ExternalAPI, NULL);
  PyDict_SetItemString(dict, "_C_API", c_api);
  Py_XDECREF(c_api);
  import_SIDLPyArrays();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlPyArrays module.");
  }
  import_array();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing Numeric Python module.");
  }
  sidl_BaseClass__import();
  _sidl_DLLType.tp_base = sidl_BaseClass_PyType();
  _sidl_DLLType.tp_bases = PyTuple_New(1);
  PyTuple_SetItem(_sidl_DLLType.tp_bases,0,                                   \
    (PyObject *)sidl_BaseClass_PyType());
  if (PyType_Ready(&_sidl_DLLType) < 0) {
    PyErr_Print();
    fprintf(stderr, "PyType_Ready on sidl.DLL failed.\n");
    return;
  }
  Py_INCREF(&_sidl_DLLType);
  PyDict_SetItemString(dict, "DLL", (PyObject *)&_sidl_DLLType);
  sidl_ClassInfo__import();
  sidl_BaseInterface__import();
  _implEPV = sidl_DLL__externals();
  if (!_implEPV) {
    Py_FatalError("Cannot load implementation for sidl class sidl.DLL");
  }
}
